9.2 Видимість та простір імен в Python, ст 72

Перед тим як перейти до класів,
 я повинен спершу розповісти вам дещо про правила видимості в Python.
Визначення класів несуть певні складнощі з простором імен, і тому ви повинні знати
 як працює видимість та простір імен, щоб розуміти що взагалі відбувається.
 До того ж, знання про це буде корисним для кожного просунутого програміста на Python.

Давайте почнемо з визначень.

Простір імен - це з'єднання імен з об'єктами.
Їхня більшість(прострір імен) вже є імплементованими у вигляді Python словників.
Прикладами просторів імен є:
 *Набір вбудованих імен(типу, функції abs(), та вбудованих назв для помилок);
 *Глобальні імена в модулях;
 *Локальні імена при викликах функцій;
 *Набір атрибутів об'єктів - також є простором імен.

Важлива річ, яку потрібно знати про простора імен - це те, що 2 різних простори
 імен ніяк між собою не зв'язані.
Для прикладу, 2 різних модулі можуть одночасно мати функцію maximize
 без жодних проблем - і для цього користувачі цих модулів повинні вказувати
 префікс, у вигляді покету, до якого той чи інший модуль належить.

До речі, я вживаю слово атрибут для будь-якого виразу, який містить крапку -
 наприклад,  вираз z.real.real є атрибутом об'єкту z. Чесно кажучи, посилання
 на імена в модулях є посиланням на атрибути; для прикладу,  вираз
 modname.funcname.modname це модуль об'єкту, де funcname це його атрибут.
У цьому випадку ми бачимо пряме з'єднання між модульним атрибутом та глобальними
 іменами, визначеними у модулі: адже вони ділять той самий простір імен.

Атрибути мають 2 опції "тільки читання", або "редагування". Але і присвоєння
 атрибутам також можливе. Ви можете змінювати атрибути модулів: можете написати
 modname.the_answer = 42. Також, змінювані атрибути можуть бути видалені за допомогою
 del. Наприклад, del modname.the_answer видалить атрибут the_answer зі списку атрибутів об'єкта
 modname.

Простора імен створюються в різні моменти і мають різний час існування.
 Вбудовані простора імен створюються, коли вперше запускається  інтерпретатор Python,
 і після цього вони ніколи не зникають.
Глобальні простора імен для модулів створюються, коли прочитані імена модулів,
 а після завершення роботи інтерпретатору простір імен модуля зникає.
Високорівневі виклики інтерпретатора, чи то зчитування скрипт файлу чи взаємодія з ним,
 є частиною модуля __main__, тому вони мають свій глобальний простір імен,
 так само як і вбудовані імена є частиною модуля  builtins).

Локальний простір імен для функції створюється при її виклику, і зникає,
 коли функція повертає значення, або виникає помилка яка не була стримана цією ж функцією.

Видимість це контекстуальна область в програмах Python, де простір імен прямодоступний.
"Прямодоступний" тут означає, що некваліфіковане(непряме) посилання на ім'я передбачає
 пошук імені в просторі імен.

Незважаючи на статичне Визначення видимостей, їх використовують динамічно.
В будь-який час виконання програми, тут може бути 3,а бо навіть 4 пов'язані області,
 простора імен яких є прямодоступними:
     *Внутрішня область, в яку програми дивляться в першу чергу, містить в собі локальні імена
     *Області будь-який відділених функцій(закритих), пошук який починється з найближчої обмеженої області, яка містить nonlocal і не містить глобальних імен
     *Передостанньою область містить глобальні імена поточного модуля
     *Остання область - це простір імен, який містить вбудовані імена.(builtins)

Якщо назва була оголошена глобально, тоді всі посилання та присвоєння йдуть напряму
 до області серенього рівня, яка містить всі глобальні назви.
Для редагування змінної, ззовні найглибшої області видимості можна використовувати nonlocal;
 якщо nonlocal не оголошено, ці змінні можна тільки читати( спроба змінити таку змінну - просто творить нову локальну змінну в найглибшій області, залишивши ідентичну назву зовнішній змінній незміненою)

Зазвичай, локальна область посилається на локальні назви поточної функції(текстуально).
Ззовні функцій, локальна область посилається на той самий простір імен, що і глобальна область: простір імен модуля.
Класові визначення отримують окремий простір в локальній області.

Розуміння текстуального функціонування цих областей є важливим: глобальна область оголошеної функції в модулі це простір імен модуля, незалежно звідки, або який елемент викликав функцію.
